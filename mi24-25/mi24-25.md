# Midterm Exam 2024./2025.

## Task 1

Using a single SQL query, for media content that has been viewed at least once in the last 5 years (based on the start
of viewing, where the period is counted backwards from the moment the query is executed, including the moment exactly 5
years before query execution), and whose titles start with “The”, and that have a duration longer than 2 hours and a
recorded rating, display the following information:

- the title of media content concatenated with the year of its release (tracktitleandyear),
- the duration of media content (duration),
- the rating of media content rounded to one decimal place (trackRating)

The following table illustrates the expected output format, but the data does not have to match the actual output:

| tracktitleandyear                | duration           | trackrating |
|----------------------------------|--------------------|-------------|
| ...                              | ...                | ...         |
| The Highwaymen (2021)            | 2 hours 12 minutes | 94.4        |
| The Mayor (2019)                 | 2 hours 10 minutes | 94.1        |
| The Congress (2015)              | 2 hours 3 minutes  | 93.5        |
| The Man Who Feels No Pain (2020) | 2 hours 17 minutes | 92.5        |
| ...                              | ...                | ...         |

Note: It is necessary to remove duplicates in the solution.

*Check column mode: 1. STRICT: both column names and order must match.*

[Problem solution](task01.sql)

---

## Task 2

Using a single SQL statement, list—for all account owners, regardless of whether they are currently active or
inactive—their identifier (ownerid), the number of profiles on their account (profilecount), the number of simultaneous
streams (streamno) allowed according to the currently active parameters of their currently active package (if they have
one), and the user's status depending on whether they have an active package or not.
Only consider account owners who were born before 1 January 1975.
If an account owner born before 1 January 1975 does not currently have an active package, display null for the number of
simultaneous streams.
The user status must be one of the following:

- "Active packet" if the user currently has an active package.
- "No active packages" if the user currently has no active package.

Sort the results alphabetically (ascending) by status, and then by ownerid in descending order.

Example output:

| ownerid | profilecount | streamno | status             |
|---------|--------------|----------|--------------------|
| 464     | 3            | 1.00     | Active packet      |
| 313     | 2            | 2.00     | Active packet      |
| 471     | 2            | null     | No active packages |
| ...     | ...          | ...      | ...                |

*Check column mode: 1. STRICT: both column names and order must match.*

[Problem solution](task02.sql)

---

## Task 3

Using a single SQL query, list the following information for all user account owners:

- their identifier, first name, and last name,
- the number of months the user has paid for the Streamflix service (paidMonths),
- the total number of free months the user has received through all their subscribed packages (freeMonths).

Only include those user account owners who have received more than 20 free months through their subscribed packages.

The table below illustrates the format of the result, but the data does not have to match the actual output:

ownerid firstname lastname paidMonths freeMonths
118 Areebah Espinoza 57 26
139 Euan Mcconnell 86 22
327 Moses Fitzgerald 115 21
... ... ... ... ...

*Check column mode: 1. STRICT: both column names and order must match.*

[Problem solution](task03.sql)

---

## Task 4

Using the streamFlix database schema, write a relational algebra expression that represents the following query:

Print codes (trackId), movie names (TrackTitle) and number of Oscar nominations of all movies that belong to the genre (genreName) 'Comedies' and have at least one Oscar nomination.

The printout should look like in the following table (the data in this table is symbolic):

| idMovie | movieName                   | NoNominations |
|---------|-----------------------------|---------------|
| 943     | Four Weddings and a Funeral | 2             |
| 549     | Men in Black                | 3             |
| 33      | Gigi                        | 9             |
| …       | …                           | …             |

Pay attention to the renaming, and especially to the name of the relation in the result!

[Problem solution](task04)

---

## Task 5

Consider a relational schema R = { A, B, C, D, E, F} and a functional dependency set { AF → BDE, F → BCE, C → D }.

a) Does the functional dependency AF → BCDE hold? Write a proof. For each step of the proof, state the name of the rule
or axiom used.

b) If the functional dependence AF → BCDE holds, is it full or partial? Justify your answer (using rules or axioms).

[Problem solution](task05)

---

## Task 6

|Attribute Name|Description|
|---|---|
|insDateTime|Insurance policy date and time|
|personID|Personal ID number (national identifier)|
|firstName|First name of the insured person|
|lastName|Last name of the insured person|
|streetNo|Street and house number|
|cityName|Name of the city or town|
|postalCode|Postal code|
|insAmount|Total insurance amount|
|insTypeID|Insurance type identifier|
|insTypeName|Insurance type name|
|insGroupID|Insurance group identifier|
|insGroupName|Insurance group name|

---

In addition to the date and time the insurance policy was concluded and the insured person, the system also records the type and group of insurance to which the policy belongs.
For example, if on March 10, 2024, at 8:15 a.m., a policy was concluded for basic auto non-life insurance in the amount of 5,000 euros, the system records the date and time of insurance as `March 10, 2024, 08:15`, the insurance type identifier as `1` (Basic auto), and the insurance group identifier as `1` (Non-life).

Each person may have multiple insurance policies, which may belong to different types and groups of insurance.
At any given moment, only one insurance policy may be concluded for the same person.

For a person (insured), the system records the residence address: the street and house number (`streetNo`), and the town/city (`cityName`) along with the postal code (`postalCode`).
Multiple people may live at the same address.
The same street and house number (e.g., `Bana Jelačića Street 5`) may exist in multiple towns.
The postal code uniquely identifies the place, although multiple places can share the same name.

Each insurance type belongs to exactly one insurance group, while a group can contain multiple insurance types.

Initial relational schema is:

```
POLICY = insDateTime, personID, firstName, lastName, streetNo, cityName, postalCode, insAmount, insTypeID, insTypeName, insGroupID, insGroupName
```

**List all recognized functional dependencies.**

Determine the key of the POLICY relational scheme so that it is in 1NF, and then gradually normalize the relational scheme to 2NF and 3NF.

Remark: when writing functional dependencies, you can use -> instead of an arrow.

In each step of normalization (1NF, 2NF, 3NF) it is necessary to write the obtained relational schemes with all the attributes and keys.

In each step, for every relational schema, list all possible keys.

*Recommended result format:*


Recognized functional dependencies:
A -> B
C -> D, E, F
...

1NF
**NAME_REL_SCHEME** = *attribute1*, *attribute2*, ...
**K1_NAME_REL_SHEME** = *attribute1*, *attribute2*, ... - chosen as the primary key **K2_NAME_REL_SHEME** = *attribute3*, *attribute4*, ...

2NF
**NAME_REL_SHEME2** = *attribute1*, *attribute2*, ...
**K_NAME_REL_SHEME2** = *attribute1*, *attribute2*, ...
...
Scheme in 2NF: **NAME_REL_SHEME2**, **NAME_REL_SHEME2_1**, f an arrow.

At each step of normalization (1NF, 2NF, 3NF), write the resulting relational schemas with all attributes and key attributes.

At each step, for each relational schema, list all possible keys.

[Problem solution](task06)
