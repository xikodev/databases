# Midterm Exam 2023./2024.

## Task 1

Using a single SQL statement list the information about

- total number of media content view starts (numberOfViews) and
- average viewing time (avgWatchingTime)

with an media age restriction (tAgeRestriction) greater than 10 years, watched at night (watching started and ended
between midnight and 5 am, excluding 05:00:00), listed by device type (deviceTypeName) and age restriction of media
content.

You can count on the fact that no single viewing time lasts longer than 24 hours.

Format the total number of media content views in accordance with the table at the bottom of the assignment text.

Calculate the individual viewing time as the difference between the end (viewEndDateTime) and the beginning (
viewStartDateTime) of media content consumption.

An example of a solution (the data in the example does not have to correspond to the real one):

| deviceTypeName         | tAgeRestriction | numberOfViews    | avgWatchingTime             |
|------------------------|-----------------|------------------|-----------------------------|
| ...                    | ...             | ...              | ...                         |
| Phone                  | 14              | total views: 170 | 42 minutes 1.56 seconds     |
| Streaming Media Player | 17              | total views: 239 | 40 minutes 3.799163 seconds |
| ...                    | ...             | ...              | ...                         |

Note: It is necessary to remove duplicates in the solution.

*Check column mode: 3. RELALG: column names must match (column order ignored).*

[Problem solution](task01.sql)

---

## Task 2

It is necessary to write an SQL query that will identify and display all media content categorized under exactly two
different genres and whose titles contain the string 'Love'. The results should be displayed with three columns: the
title of the media content (title), the name of the first genre (genre1), and the name of the second genre (genre2).

It is important to ensure that for each media content, the genres are displayed so that the genre with the smaller
genreid is in the column genre1, thereby avoiding displaying the same media content multiple times with reversed pairs
of genres. The query should include a check to ensure that all displayed media content is categorized under exactly two
genres.

The table below illustrates the appearance of the results, but the data in the table may not match the exact results.

| title         | genre1        | genre2       |
|---------------|---------------|--------------|
| A Secret Love | Documentaries | LGBTQ Movies |
| Love Is War   | Comedies      | Dramas       |
| ...           | ...           | ...          |

*Check column mode: 4. PERMISSIVE: try 3 (to match by names); if not - try 2 (use column order).*

[Problem solution](task02.sql)

---

## Task 3

Using a single SQL statement for films nominated for an Oscar in at least one category in the years 1940 to 2010 (both
inclusive), which won an Oscar in each category in which they were nominated, print title of the movie, year of the
Oscars awards, category name in which they were nominated, rating given by the users (movieRating), earnings from the
movie and earnings category (incomeCategory).

Round the rating to one decimal, and determine the earnings category as follows:

- High for movies that earned more than 400 million
- Medium for movies that earned more than 100 million and less than or equal to 400 million
- Low for movies that earned less than or equal to 100 million
- Unknown for movies for which earnings are not known

Sort the results by year of nomination in ascending order, then by movie rating in descending order and by category name
in which they were nominated in ascending order.

Help: movies that received Oscars in all nominated categories, the number of nominations is equal to the number of
Oscars won.

An example of a solution (the data in the example does not have to correspond to the real one):

| movieTitle                                     | oscarYear | oscarCategoryName     | movieRating | boxIncome | incomeCategory |
|------------------------------------------------|-----------|-----------------------|-------------|-----------|----------------|
| The Battle of Midway                           | 1943      | DOCUMENTARY           | 97.4        | null      | Unknown        |
| ...                                            | ...       | ...                   | ...         | ...       | ...            |
| Tarzan                                         | 2000      | MUSIC (Original Song) | 90.7        | 448191819 | High           |
| ...                                            | ...       | ...                   | ...         | ...       | ...            |
| The Lordt of the Rings: The Return of the King | 2004      | MAKEUP                | 48.9        | 169525554 | Medium         |
| ...                                            | ...       | ...                   | ...         | ...       | ...            |

*Check column mode: 3. RELALG: column names must match (column order ignored).*

[Problem solution](task03.sql)

---

## Task 4

**Task instructions**

You need to enter your answer in the text box below the question, using the approach described in the column **Textual
shape** of the following table.

| Relational algebra expression                                                                                                         | Description                                             | Textual shape                                 |
|---------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------|-----------------------------------------------|
| $\text{r1} \bowtie \text{r2}$                                                                                                         | Natural join                                            | r1 ⋈ r2                                       |
| $\text{r1} \underset{\text{att1 = att2} \, \land \, (\text{att3 > att4} \, \lor \, \text{att5 <= att6})}{\bowtie} \text{r2}$          | Conditional join                                        | r1 ⋈{att1=att2 ∧ (att3>att4 ∨ att5<=att6)} r2 |
| $\text{r1} \underset{\text{att1 = att2}}{* \! \bowtie} \text{r2}, \, \text{r1} \underset{\text{att1 = att2}}{\bowtie \! *} \text{r2}$ | Conditional outer joins                                 | r1 \*⋈{att1=att2} r2, r1 ⋈\*{att1=att2} r2    |
| $\sigma_{\text{att1} \, \neq \, \text{att2} \, \land \, \text{att2 = 'test'}} (\text{r1})$                                            | Selection                                               | σ{att1≠att2 ∧ att2='test'}(r1)                |
| $\pi_{\text{att1, att2}} (\text{r1})$                                                                                                 | Projection                                              | π{att1,att2}(r1)                              |
| $\rho_{\text{r2(att1, att2)}} (\text{r1})$                                                                                            | Rename                                                  | ρ{r2(att1,att2)}(r1)                          |
| $_{\text{att1, att2}} \text{G}_{\text{SUM(att3)}} (\text{r1})$                                                                        | Aggregation                                             | {att1,att2}G{SUM(att3)}(r1)                   |
| $\text{r1} \cup \text{r2}, \; \text{r1} \cap \text{r2}, \; \text{r1} \setminus \text{r2}, \; \text{r1} \times \text{r2}$              | Union, Intersection, Set subtraction, Cartesian product | r1 ∪ r2, r1 ∩ r2, r1 \ r2, r1 × r2            |

For example, the following relational algebra expression

$$
\large \rho_{\text{student(studentid, firstname, lastname)}} (\pi_{\text{studentid, firstname, lastname}} (\text{student} \bowtie \text{attendance}))
$$

is entered as the following text line

ρ{student(studentid,firstname,lastname)}(π{studentid,firstname,lastname}(student ⋈ attendance))

You can find all the needed text symbols in the following table, which can be copy-pasted to form your answer

| Name                             | Textual shape             |
|----------------------------------|---------------------------|
| Relational operators             | ρ π σ G ∪ ∩ \ ⋈ \*⋈ ⋈\* × |
| Logical operators and conditions | <= >= ≠ = < > ∧ ∨         |

Using the streamFlix database schema, write a relational algebra expression that represents the following query: Print
the codes, names and surnames of the actors named *** 'Michael' ***and the names of all movies in which they acted.
Also, the number of nominations for the Oscar award must be printed with each movie. If one of the movie was not
nominated for an Oscar, it is necessary to write zero (0). If there are actors named Michael who have not acted in any
movies, they shouldn't be listed. The printout should look like in the following table (the data in this table is
symbolic):

| codeActor | nameActor | surnameActor | nameFilm  | numberNomination |
|-----------|-----------|--------------|-----------|------------------|
| 18232     | Michael   | Caine        | Inception | 8                |
| 18232     | Michael   | Caine        | Quincy    | 0                |
| 24750     | Michael   | Rya          | War Horse | 6                |
| 18840     | Michael   | Richard      | Bee Movie | 0                |
| ...       | ...       | ...          | ...       | ...              |

Pay attention to the renaming, and especially to the name of the relation in the result!

[Problem solution](task04)

---

## Task 5

Consider a relational schema R = { T, U, V, W, X, Y, Z} and a functional dependency set { TU → XY, T → V, Y → W, U →
ZW }.

It is necessary to prove that TU is a candidate key for the relational schema R. Check in detail all the properties
that (by definition) a key of a relational schema should satisfy. When verifying key properties, for each step of the
verification, state the axiom or rule you used. Finally, write a conclusion whether TU is a candidate key and explain
why you claim this.

[Problem solution](task05)

---

## Task 6

| Attribute Name | Attribute Description                                                                            |
|----------------|--------------------------------------------------------------------------------------------------|
| patId          | Patient identifier                                                                               |
| patFirstName   | Patient first name                                                                               |
| patLastName    | Patient last name                                                                                |
| patDOB         | Date of birth of the patient                                                                     |
| dateTimeExam   | Date and time when the examination will be performed (TIMESTAMP)                                 |
| clinicId       | Identifier of the clinic where examinations are performed                                        |
| clinicName     | Name of the clinic - e.g. ENT outpatient clinic 1, Physiiatric outpatient clinic and similar     |
| healthInstId   | Healthcare institution identifier                                                                |
| healthInstName | Name of the health care institution - e.g. Clinical Hospital Dubrava, Health Center Zagreb-Istok |
| examTypeId     | Identifier of the type of examination for which the patient is being ordered                     |
| examTypeName   | Name of the type of examination – e.g. First examination by a physiatrist                        |

Examinations are performed in clinics of health institutions starting at the scheduled date and time (e.g. 29.4.2024. in
15:30).
Each clinic belongs to only one health institution, while several clinicss can belong to one health institution. It is
possible to perform different types of examinations in one clinic, but the system does not record which clinic performs
which types of examinations.
Only one order can be recorded for the same patient with the same examination start.
Also, only one order can be recorded for the same clinic with the same start of examination.

The initial relational scheme is:

```
ORDER = patId, patFirstName, patLastName, patDOB, dateTimeExam, clinicId, clinicName, healthInstId, healthInstName, examTypeId, examTypeName
```

List all recognized functional dependencies.

Determine the key of the ORDER relational scheme so that it is in 1NF, and then gradually normalize the relational
scheme to 2NF and 3NF.

Remark: when writing functional dependencies, you can use -> instead of an arrow.

In each step of normalization (1NF, 2NF, 3NF) it is necessary to write the obtained relational schemes with all the
attributes and keys.

In each step, for every relational schema, list all possible keys.

*Recommended result format:*

Recognized functional dependencies:
A -> B
C -> D, E, F
...

1NF
NAME_REL_SCHEME = attribute1, attribute2, ...
K1_NAME_REL_SHEME = attribute1, attribute2, ... - chosen as the primary key K2_NAME_REL_SHEME = attribute3,
attribute4, ...

2NF
NAME_REL_SHEME2 = attribute1, attribute2, ...
K_NAME_REL_SHEME2 = attribute1, attribute2, ...
...
Scheme in 2NF: NAME_REL_SHEME2, NAME_REL_SHEME2_1,

3NF
...
Scheme in 3NF: NAME_REL_SHEME3, NAME_REL_SHEME3_1,...

[Problem solution](task06)
